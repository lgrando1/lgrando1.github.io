
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    [{"authors":null,"categories":null,"content":"Leonardo Grando is a Brazilian Assistant Professor at UNASP and a Technology Ph.D. candidate at University of Campinas (UNICAMP). Specializing in complex systems, agent-based simulations (ABMS), artificial intelligence (AI), and the Internet of Things (IoT), I focus on developing cutting-edge machine learning models and programming solutions.\nWith expertise in leading technologies like NetLogo, Python, R, LaTeX,Cyber security, Web Development, Data Bases, and Linux, my current Ph.D. research is centered on IoT device swarms (UAVs) for perpetual flight, leveraging agent-based modeling for efficiency. This involves using NetLogo for simulation and Python and R for advanced data mining.\nPreviously, I transitioned from a career in the automotive industry, where I focused on productivity improvements, into the academic field. Since 2019, I have contributed to data science, teaching, and research, including experience as a teacher at the fundamental high school to undergraduate level.\nFollow me in Mastodon and my Telegram Channel\nDownload my Resume .\nBaixe meu Currículo .\n","date":1702339200,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1702339200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"Leonardo Grando is a Brazilian Assistant Professor at UNASP and a Technology Ph.D. candidate at University of Campinas (UNICAMP). Specializing in complex systems, agent-based simulations (ABMS), artificial intelligence (AI), and the Internet of Things (IoT), I focus on developing cutting-edge machine learning models and programming solutions.","tags":null,"title":"Leonardo Grando","type":"authors"},{"authors":[],"categories":[],"content":"Lendo artigo da Nature fiquei preocupado em relação a privacidade e o uso de meus dados quando utilizandos os LLMs, como por exemplo o Chat-GPT, Gemini e o CoPilot. Sem contar que estas ferramentas nescessitam de acesso a internet. Alguns sites como o Hugging Face permitem testar alguns usos destas ferramentas ferramentas utilizando uma biblioteca para a linguagem Python, como eu já descrevi em uma postagem anterior.\nMas como utilizar estas ferramentas como se fosse abrir um site e conversar com elas? Eu queria algo mais completo e como sou usuário Linux (uso o Pop_OS! 20.04), encontrei este post muito bem explicado de como rodar uma LLM off-line no Linux e resolvi replicar, e conto a experiência aqui neste post.\nO Ollama é uma ferramenta que facilita o processo de baixar e rodar os modelos LLMs de código aberto. Ele pode ser instalado no Windows, MacOS e o Linux. Apenas seguir o procedimento de instalação presente no site deles.\nNo meu caso utilizei o comando abaixo, mas recomendo que você siga o procedimento descrito pelo site pois o mesmo pode alterar conforme novas atualizações.\nRepetindo: siga o procedimento de instalação conforme descrito no site deles, não este daqui.\ncurl -fsSL https://ollama.com/install.sh | sh O código acima irá baixar o Ollama em sua máquina e rodar o script de instalação. Você pode auditar o script de instalação aqui\nA minha máquina é um notebook Acer Nitro que adquiri no final de 2020. Ele possui um Core i5 9300H, 16 GB de RAM e uma GPU Nvidia Geforce GTX 1650. O que fica interessante, pois o Ollama reconheceu a GPU.\nNa postagem que usei como referência para instalar, o autor descreve que o Notebook dele não possui uma GPU discreta, o que influenciou no desempenho. E o modelo escolhido vai também influenciar.\nHora de testar se o Ollama está rodando, num browser digite:\nAqui mostrou que está funcionando.\nAgora é hora de baixar o modelo LLM. No site existe vários modelos. Já testei o llama3.1. Este modelo desenvolvido pela Meta e que possui três níveis de parâmetros 8, 70 e 405 bilhões de parâmetros. Acabei escolhendo o modelo de 8B. São aproximadamente 4.7 GB utilizado de armazenamento. Mas ai fica o critério de cada um. Para este post vou apresentar o processo de instalação do modelo phi3.5 da Microsoft.\nPara dar um “pull” em um modelo LLM desejado, utiliza-se o comando:\nollama pull \u0026lt;Nome_da_LLM\u0026gt; Então para baixar e instalar o modelo phi3.5 da Microsoft.\nollama pull phi3.5 Agora vamos listar as imagens que estão presentes no seu computador.\nollama list Para rodar uma das LLMs com o código:\nollama run \u0026lt;Nome_da_LLM\u0026gt; No caso da Phi3\nollama run phi3.5 Mas antes de tudo, para fins de demostração, vou garantir que não está ocorrendo comunicação com a internet:\nAqui vou pedir para que ele me gere um código Python para connectar a uma base do MySQL:\nNão vou me extender na utilização dele ou de outro modelo, mas é possível utilizar o próprio terminal para conversar com a LLM, e existem formas de conversar via interface gráfica, o que fica para um próximo post.\nAgora para avaliar o uso computacional da minha máquina, vou utilizando o utilitário Nvidia-smi em que é possivel ver o quanto ele está utilizando os recursos da GPU\nE em relação ao uso computacional da CPU e do consumo de memória RAM ele não ficou “tão pesado”, ,as lembrando que o Phi3.5 é um modelo particularmente pequeno. O print abaixo apresenta o consumo computacional durante uma inferencia:\nAgora para sair do Ollama, basta digitar no prompt:\n/bye E para gerenciar e deletar os modelos LLMs, é possivel listar e solicitar a remoção da imagem. PS: peço desculpas na imagem abaixo por que eu digitei um comando errado, por isto ocultei o mesmo, para evitar confusão.\nollama rm \u0026lt;nome_da_LLM\u0026gt; Este tutorial aborda apenas alguns aspectos do uso do Ollama, o tutorial que serviu como base para este experimento possui mais informações, como utilizar a interface gráfica com Docker e também como desinstalar o Ollama. Assim você tem um assistente local para lhe ajudar em tarefas simples. Ontem eu testei o uso do Llamma 3.1 para criar um banco de dados no MySQL e para implementar um código Python para interagir com este banco de dados e o código proposto funcionou. Mas é preciso testar mais.\nSucesso a todos!\n","date":1726963200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1727017760,"objectID":"ddea2163018f2b9dbff519740e00976c","permalink":"https://lgrando1.github.io/post/ollama/","publishdate":"2024-09-22T00:00:00Z","relpermalink":"/post/ollama/","section":"post","summary":"Como rodar uma Ferramenta LLM Off-line no Linux","tags":["GPT","Ollama","prompt","enginnering","IA","AI","Offline","GPU","terminal"],"title":"Usando uma Ferramenta LLM no Linux de Forma Offline","type":"post"},{"authors":[],"categories":[],"content":"Realizei recentemente o curso Prompt Engineering for ChatGPT e gostaria de compartilhar algumas anotações que realizei durante o mesmo.\nEstas ferramentas não podem ser consideradas como fonte de fatos, mas são excelentes como suporte para ideias e quem sabe para tirar da gaveta aquela ideia de um livro.\nO objetivo desta série é criar postagens com quatro estratégias por post. Estou utilizando como exemplo o Chat-GPT em sua versão grátis, mas você pode testar em qualquer outra ferramenta.\nCaso queira conhecer melhor o funcionamento destas ferramentas, recomendo o texto do Stephen Wolfram e o curso Prompt Engineering for ChatGPT que pode ser auditado gratuitamente no Coursera.\nOs links incluem exemplos de cada item.\n1 - São ferramentas estocásticas, por isto pode não ocorrer repetitividade nas respostas, já que a sua resposta depende de como elas foram treinadas: Conforme você realiza o prompt, as ferramentas podem responder de formas diferentes, por isto é importante o refino da sua questão e testar várias estratégias.\nAinda considerando a pergunta, quantos prêmios Nobéis o Brasil já foi agraciado? O exemplo 1 e o exemplo 2 apresentam respostas distintas para a mesma questão.\n2 - Você pode solicitar a esta ferramenta para que ela aja conforme um personagem (ex: professor, consultor, etc.) e que a resposta seja direcionada para determinado público (jovens da terceira idade, adolescente). A estrutura deste prompt é:\nAja como P e faça A\nOnde P é igual ao personagem que você deseja e A ação que você espera dele.\nNeste exemplo, vou pedir para ele agir como um professor de Línguas, depois vou pedir para ele explicar o meu erro usando um exemplo de obra literária e depois para ele contextualizar um assunto atual para um cidadão do ano 1700.\n3 - Você pode enviar novas informações para o Prompt. Estas ferramentas possuem uma limitação do processo de treinamento. Você pode fornecer novas informações para que ele possa aprimorar a resposta.\nNeste exemplo pedi para ele os presidentes que governaram o Brasil entre os anos 2000 a 2024 e solicitei atualização das informações com o novo presidente.\n4 - Refinamento de questões. Observe que a clareza com que você faz os questionamentos é importante para que você tenha respostas mais próximas do que deseja. Não adianta você pedir: Quais foram os presidentes?, se você quer uma resposta limitada por tempo. Mas você pode pedir para ele como melhorar sua pergunta.\nPor enquanto são estas dicas, vimos que podem ocorrer variações nas respostas, que estas ferramentas podem agir como determinado personagem para atingir um público específico, que você pode treinar a ferramenta localmente com novas informações para que sua resposta seja mais atual e que a própria ferramenta pode lhe ajudar a refinar as suas questões.\n","date":1714176000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1714230560,"objectID":"cc0fdc17dc780828aaabd445e7dbdc1c","permalink":"https://lgrando1.github.io/post/prompt1/","publishdate":"2024-04-27T00:00:00Z","relpermalink":"/post/prompt1/","section":"post","summary":"Alguns padrões para facilitar a utilização do Chat-GPT","tags":["GPT","Chat-GPT","prompt","enginnering","IA","AI"],"title":"Como usar melhor o Chat-GPT e outras ferramentas generativas-Parte 1","type":"post"},{"authors":[],"categories":[],"content":"A plataforma Hugging Face é uma portal onde a comunidade de aprendizado de máquina colabora com modelos, conjunto de dados e aplicações.\nAo acessar o site e clicar no link Models é possível buscar por variados modelos voltados para várias tarefas de aprendizado de máquina visão computacional, processamento natural de linguagem, áudio, dados tabulares, aprendizado por reforço e outros tipos.\nNeste post apresentaremos uma introdução de como utilizar estas bibliotecas em sua máquina (ou no Google Colab). Como exemplo é demostrado a realização de duas tarefas: o preenchimento de mascaras de texto (completar um espaço de um texto) e o resumo de um texto.\nSão dois modelos/exemplos simples, mas o objetivo é realmente despertar a curiosidade em conhecer mais sobre esta plataforma.\nAlgumas considerações:\nAo baixar o modelo em sua maquina, alguns modelos são grandes, como o segundo modelo deste tutorial que possui mais do que 1,5 GB. Neste link é possível ver como gerenciar o cache destes modelos; Se atente ao modelo que você vai testar, pois já foram encontrados problemas de segurança; Se atente também nas licenças de conteúdo dos modelos e também possíveis dependências. Se atente a documentação presente em cada página dos modelos; Alguns modelos de aprendizados de máquinas exigem bastante recursos computacionais, ao escrever este post, várias vezes o Jupyter acabou resetando. Apenas para comparativo, este computador é um Core i5 de nona geração (Intel i5 - 9300H) e 8 GB de RAM. Infelizmente ainda não consegui ativar a GPU para tarefas de Machine Learning no Linux. No Google Colab é possível ativar o suporte ao GPU mesmo no tier grátis. Alertas feitos, vamos aos modelos:\nPrimeiro é necessário a biblioteca Transformers para poder baixar e treinais os modelos pré treinados.\nNo momento da escrita deste post estão disponíveis 564772 modelos.\nAqui esta presente a documentação de como instalar esta biblioteca.\nimport transformers from transformers import pipeline #Apenas para suprimir erros, não nescessário. import logging logging.getLogger(\u0026#34;transformers\u0026#34;).setLevel(logging.ERROR) Tarefa 1 - preenchimento de mascaras Para realizar a tarefa de preenchimento de mascaras, utilizaremos o modelo BERTimbau Base (aka “bert-base-portuguese-cased” [1]\nIremos utilizar neste caso a versão base.\nA tarefa realizada será “fill-mask” e iremos pedir que ele devolva 5 respostas para a frase “Batatinha quando nasce, esparrama pelo [MASK]” onde [MASK] é o texto que será preenchido pelo token.\n[1] SOUZA, Fábio e NOGUEIRA, Rodrigo e LOTUFO, Roberto. BERTimbau: pretrained BERT models for Brazilian Portuguese. 2020, [S.l: s.n.], 2020.\nA primeira linha do código abaixo indicar a tarefa a ser executada e o modelo a ser utilizado e a segunda linha aplica o modelo para o texto escolhido.\nmascarar = pipeline(\u0026#34;fill-mask\u0026#34;, model=\u0026#34;neuralmind/bert-base-portuguese-cased\u0026#34;) texto = mascarar(\u0026#34;Batatinha quando nasce, esparrama pelo [MASK]\u0026#34;) for x in range(len(texto)): print(texto[x]) {\u0026#39;score\u0026#39;: 0.3925571143627167, \u0026#39;token\u0026#39;: 8105, \u0026#39;token_str\u0026#39;: \u0026#39;chão\u0026#39;, \u0026#39;sequence\u0026#39;: \u0026#39;Batatinha quando nasce, esparrama pelo chão\u0026#39;} {\u0026#39;score\u0026#39;: 0.10256581008434296, \u0026#39;token\u0026#39;: 1831, \u0026#39;token_str\u0026#39;: \u0026#39;corpo\u0026#39;, \u0026#39;sequence\u0026#39;: \u0026#39;Batatinha quando nasce, esparrama pelo corpo\u0026#39;} {\u0026#39;score\u0026#39;: 0.05736977979540825, \u0026#39;token\u0026#39;: 1147, \u0026#39;token_str\u0026#39;: \u0026#39;mundo\u0026#39;, \u0026#39;sequence\u0026#39;: \u0026#39;Batatinha quando nasce, esparrama pelo mundo\u0026#39;} {\u0026#39;score\u0026#39;: 0.047487251460552216, \u0026#39;token\u0026#39;: 388, \u0026#39;token_str\u0026#39;: \u0026#39;ar\u0026#39;, \u0026#39;sequence\u0026#39;: \u0026#39;Batatinha quando nasce, esparrama pelo ar\u0026#39;} {\u0026#39;score\u0026#39;: 0.023149045184254646, \u0026#39;token\u0026#39;: 9169, \u0026#39;token_str\u0026#39;: \u0026#39;rosto\u0026#39;, \u0026#39;sequence\u0026#39;: \u0026#39;Batatinha quando nasce, esparrama pelo rosto\u0026#39;} Observe nas resposta acima que o maior “score” foi para a frase que contém o token “chão”.\nTarefa 2 - Resumo de textos Para realizar o processo de resumo de texto (“summarization”), iremos utilizar como exemplo o modelo facebook/bart-large-cnn [2]\nUtilizaremos o texto que está presente na própria página do modelo.\n[2] LEWIS, Mike e colab. BART: Denoising sequence-to-sequence pre-training for natural language generation, translation, and comprehension. CoRR, v. abs/1910.13461, 2019. Disponível em: http://arxiv.org/abs/1910.13461.\nresumir = pipeline(\u0026#34;summarization\u0026#34;, model=\u0026#34;facebook/bart-large-cnn\u0026#34;) texto = \u0026#34;\u0026#34;\u0026#34;The tower is 324 metres (1,063 ft) tall, about the same height as an 81-storey building, and the tallest structure in Paris. Its base is square, measuring 125 metres (410 ft) on each side. During its construction, the Eiffel Tower surpassed the Washington Monument to become the tallest man-made structure in the world, a title it held for 41 years until the Chrysler Building in New York City was finished in 1930. It was the first structure to reach a height of 300 metres. Due to the addition of a broadcasting aerial at the top of the tower in 1957, it is now taller than the Chrysler Building by 5.2 metres (17 ft). Excluding transmitters, the Eiffel Tower is the second tallest free-standing structure in France after the Millau Viaduct.\u0026#34;\u0026#34;\u0026#34; resumo = …","date":1711238400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1711306800,"objectID":"e6f974f25e8c4413859549a7cda3679a","permalink":"https://lgrando1.github.io/post/hface/","publishdate":"2024-03-24T00:00:00Z","relpermalink":"/post/hface/","section":"post","summary":"Criando um pipeline para testar os modelos presentes no Hugging Faces","tags":["Hugging Face","IA","ML","Generativos","Python"],"title":"Utilizando a plataforma Hugging Face para testar modelos de aprendizado de máquina.","type":"post"},{"authors":[],"categories":[],"content":"Neste post é apresentado uma rotina de aprendizado de máquina supervisionado utilizando a biblioteca TensorFlow para realizar o reconhecimento e classificação de imagens da base de dados MNIST. Esta base de dados consiste em imagens de numeros escritos a mão e seus respectivos rótulos. A idéia deste post é treinar um modelo de rede neural que reconheça os padrões destas imagens e as classifiquem com o respectivo número.\nO conteúdo desta atividade de classificação é composto de:\nImportar as bibliotecas; Importar o conjunto de dados e dividi-los entre base treino e de teste; Aplicar o processo de Hot Encoding nas classes de respostas; Pré-processamento dos dados para que possam ser uitilizados no treinamento da rede; Criação do modelo de rede neural; Treinamento do modelo com os dados de treinamento; Realizar a predição e comparação com os dados de teste. 1. Importação das bibliotecas necessárias, incluindo o TensorFlow import tensorflow as tf import numpy as np tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR) print(\u0026#39;Using TensorFlow version\u0026#39;, tf.__version__) #Processo de hot-encoding from tensorflow.keras.utils import to_categorical #para criar as camadas do modelo de rede neural from tensorflow.keras.models import Sequential from tensorflow.keras.layers import Dense #para visualizar as imagens from matplotlib import pyplot as plt %matplotlib inline 2024-03-24 10:02:13.310353: I tensorflow/tsl/cuda/cudart_stub.cc:28] Could not find cuda drivers on your machine, GPU will not be used. 2024-03-24 10:02:13.370354: I tensorflow/tsl/cuda/cudart_stub.cc:28] Could not find cuda drivers on your machine, GPU will not be used. 2024-03-24 10:02:13.371713: I tensorflow/core/platform/cpu_feature_guard.cc:182] This TensorFlow binary is optimized to use available CPU instructions in performance-critical operations. To enable the following instructions: AVX2 FMA, in other operations, rebuild TensorFlow with the appropriate compiler flags. 2024-03-24 10:02:14.341836: W tensorflow/compiler/tf2tensorrt/utils/py_utils.cc:38] TF-TRT Warning: Could not find TensorRT Using TensorFlow version 2.13.1 2: Importar a base de dados e dividi-la em bases treino e de teste A própria biblioteca Tensorflow já disponibiliza esta base.\nfrom tensorflow.keras.datasets import mnist (x_train, y_train),(x_test, y_test) = mnist.load_data() Dimensões dos arrays importados A base de dados MNIST é composta por 70000 imagens em escala de cinza de dimensões de 28 por 28 e seus respectivos rótulos. Neste trabalho esta base foi dividida com 60000 instancias de treino e 10000 de teste para poder verificar a performance do treinamento. Cada valor dos pixels representam um valor integral (entre 0 a 255) na escala de cinza.\nprint(\u0026#34;x_train shape\u0026#34;, x_train.shape) print(\u0026#34;y_train shape\u0026#34;, y_train.shape) print(\u0026#34;x_test shape\u0026#34;, x_test.shape) print(\u0026#34;y_test shape\u0026#34;, y_test.shape) x_train shape (60000, 28, 28) y_train shape (60000,) x_test shape (10000, 28, 28) y_test shape (10000,) Visualizando uma imagem presente na base de treino # Apresentando uma imagem da base de treino. plt.imshow(x_train[1], cmap=\u0026#34;binary\u0026#34;) plt.show() Para ver o seu rótulo de treino: # O valor da classe na posição 1 print(y_train[0]) #valor 5 print(y_train[1]) #valor 0 5 0 Para ver todos os rótulos presentes na base de treino: # Os valores presentes na classe de treino print(set(y_train)) {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 3 - Processo de hot encoding nas classes. Para que as classes de respostas possam passar pelo processo de treinamento e de testes, é necessario aplicar o processo de pré-processamento de hot encoding (criação de variaveis dummies) nas classes de respostas.\nCodificando os rótulos y_train_encoded = to_categorical(y_train) y_test_encoded = to_categorical(y_test) Conhecendo as dimensões das bases de dados codificadas print(\u0026#34;y_train_encoded shape\u0026#34;, y_train_encoded.shape) print(\u0026#34;y_test_encoded shape\u0026#34;, y_test_encoded.shape) y_train_encoded shape (60000, 10) y_test_encoded shape (10000, 10) Visualizando um rótulo codificado. print(y_train_encoded[0]) #valor 5 print(y_train_encoded[1]) #valor 0 [0. 0. 0. 0. 0. 1. 0. 0. 0. 0.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 0.] 4 Pré-processamento. Transformar a matriz de 2 dimensões (28x28 pixels com valores de 0 a 255) em um uníco vetor de dimensão 784. x_train_reshaped = np.reshape(x_train, (60000, 784)) x_test_reshaped = np.reshape(x_test, (10000, 784)) print(\u0026#34;x_train_reshaped_shape\u0026#34;, x_train_reshaped.shape) print(\u0026#34;x_test_reshaped_shape\u0026#34;, x_test_reshaped.shape) x_train_reshaped_shape (60000, 784) x_test_reshaped_shape (10000, 784) Normalização dos a x_mean = np.mean(x_train_reshaped) x_std = np.std(x_train_reshaped) epsilon = 1e-10 x_train_norm = (x_train_reshaped-x_mean) / (x_std + epsilon) x_test_norm = (x_test_reshaped-x_mean) / (x_std + epsilon) 5: Criando o modelo de rede neural. Modelo será composto de uma camada de entrada, uma camada interna oculta e uma camada de saída. model = Sequential([ Dense(56, …","date":1711152000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1711220400,"objectID":"6d6179f9140fcb8ab89a3df010a497ad","permalink":"https://lgrando1.github.io/post/pythoncv/","publishdate":"2024-03-23T00:00:00Z","relpermalink":"/post/pythoncv/","section":"post","summary":"Classificação imagens utilizando rede neurais e Python","tags":["TensorFlow","IA","ML","Imagens","classificação","Python"],"title":"Classificação de imagens com o TensorFlow.","type":"post"},{"authors":[],"categories":[],"content":"2024/02/26 Thinking in a society without centralization and auto-regulated, like the ants and insects societies; Create a way to summarize society’s problems TODO list. Request to everybody to stop talk about politics and start thinking about these problems; Think how to use Artificial Intelligence to improve society care and not only profits. Give a way to person live without need be online. ","date":1708905600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1708960160,"objectID":"27dc9bd42ebab287eca8667eea83805c","permalink":"https://lgrando1.github.io/ideas/","publishdate":"2024-02-26T00:00:00Z","relpermalink":"/ideas/","section":"","summary":"Some ideas to a better world","tags":["ideas"],"title":"Ideas","type":"page"},{"authors":[],"categories":null,"content":"","date":1702387800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1702387800,"objectID":"7d197cf7e9f275a966f656037893aa7f","permalink":"https://lgrando1.github.io/talk/wsc-2023/","publishdate":"2023-12-12T00:00:00Z","relpermalink":"/talk/wsc-2023/","section":"event","summary":"Presenting the Extend Abstract of our work \"MODELING AND SIMULATION FOR FARMING DRONE BATTERY RECHARGING\" in the Simulation Around the World (SATW) Track.","tags":["Agent-Based","Simulation","presentation","Drones","Farm"],"title":"WSC 2023","type":"event"},{"authors":["Juan F Galindo Jaramillo","Leonardo Grando","Jose Roberto Emiliano Leite","Edson L. Ursini"],"categories":null,"content":"","date":1702339200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1702339200,"objectID":"bfb66ebafcdfcdbb5446c7ff6a157428","permalink":"https://lgrando1.github.io/publication/jaramillo-2023/","publishdate":"2023-12-12T00:00:00Z","relpermalink":"/publication/jaramillo-2023/","section":"publication","summary":"Using Agent-Based Models (ABM) for disease incidence may help decision-making processes. This work shows an ABM for cervical cancer detection. Our results show the relevance of social indicators.","tags":["Cancer","Simulation","Agent-Based","Detection"],"title":"Agent-Based Model For Analysis of Cervical Cancer Detection","type":"publication"},{"authors":["Leonardo Grando","Juan F Galindo Jaramillo","Jose Roberto Emiliano Leite","Edson L. Ursini"],"categories":null,"content":"","date":1702339200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1702339200,"objectID":"742878604d28f8a3e34a0a21b3e871e8","permalink":"https://lgrando1.github.io/publication/grando-2023/","publishdate":"2023-12-12T00:00:00Z","relpermalink":"/publication/grando-2023/","section":"publication","summary":"The Connected Farm is composed of several elements that communicate with each other through a 4G/5G Radio Base Station (RBS) placed in the middle of the farm. This RBS is connected to the Internet, allowing communication for all kinds of autonomous devices, performing uninterrupted tasks. This work simulates the Connected Farm environment for an autonomous drone. Our model intends to define when each drone needs to recharge its batteries, with no collusion regarding this recharging decision, reducing the drone’s battery usage due to the absence of this communication.","tags":["Drones","Simulation","Agent-Based","Precision Agriculture"],"title":"Modeling and Simulation for Farming Drone Battery Recharging","type":"publication"},{"authors":[],"categories":[],"content":"Desenvolvimentos dos componentes da Série de Taylor Para expandir computacionalmente é possivel utilizar a função sympy.series.\nA documentação desta função do Sympy pode ser encontrada aqui\nO código fonte deste Jupyter Notebook pode ser encontrado aqui\n# importando as funções nescessarias para a expansão das funções: from sympy import Symbol, cos, series, E, sin, ln, cosh, sinh z = Symbol(\u0026#39;z\u0026#39;) Series de Taylor Utiliza-se a seguinte expressão para o desenvolvimento das expressões das séries de Taylor:\n$f(z)=\\sum_{k=0}^{\\infty}(z-a)^k\\frac{f^{k}(a)}{k!}$\nDesenvolva as séries de Taylor para as funções a seguir nos pontos determinados:\nA) $f(z) = e^z$ para $a = 0$ Calculando as derivadas:\n$f^0(z)=e^z \\Rightarrow f^0(0) = 1$\n$f^1(z)=e^z \\Rightarrow f^1(0) = 1$\n$f^2(z)=e^z \\Rightarrow f^2(0) = 1$\n$f^3(z)=e^z \\Rightarrow f^3(0) = 1$\n$f^4(z)=e^z \\Rightarrow f^4(0) = 1$\nPara k = 0\n$(z-0)^0 \\frac{f^0(0)}{0!} = 1$\nPara k = 1\n$(z-0)^1 \\frac{f^1(0)}{1!} = z$\nPara k = 2\n$(z-0)^2 \\frac{f^2(0)}{2!} = \\frac{z^2}{2!}$\nPara k = 3\n$(z-0)^3 \\frac{f^3(0)}{3!} = \\frac{z^3}{3!}$\nPara k = 4\n$(z-0)^4 \\frac{f^4(0)}{4!} = \\frac{z^4}{4!}$\nEntão:\n$f(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!}… $\n#Computacionalmente: series(E**(z),z) $\\displaystyle 1 + z + \\frac{z^{2}}{2} + \\frac{z^{3}}{6} + \\frac{z^{4}}{24} + \\frac{z^{5}}{120} + O\\left(z^{6}\\right)$\nB) $f(z) = \\cos(z)$ para $a = 0$ Calculando as derivadas:\n$f^0(z)=\\cos(z) \\Rightarrow f^0(0) = 1$\n$f^1(z)=-\\sin(z) \\Rightarrow f^1(0) = 0$\n$f^2(z)=-\\cos(z) \\Rightarrow f^2(0) = -1$\n$f^3(z)=\\sin(z) \\Rightarrow f^3(0) = 0$\n$f^4(z)=\\cos(z) \\Rightarrow f^4(0) = 1$\nPara k = 0\n$(z-0)^0 \\frac{f^0(0)}{0!} = 1$\nPara k = 1\n$(z-0)^1 \\frac{f^1(0)}{1!} = 0$\nPara k = 2\n$(z-0)^2 \\frac{f^2(0)}{2!} = -\\frac{z^2}{2!}$\nPara k = 3\n$(z-0)^3 \\frac{f^3(0)}{3!} = 0$\nPara k = 4\n$(z-0)^4 \\frac{f^4(0)}{4!} = -\\frac{z^4}{4!}$\nEntão:\n$f(z) = 1 - \\frac{z^2}{2!} + \\frac{z^4}{4!} … $\n#Computacionalmente: series(cos(z),z) $\\displaystyle 1 - \\frac{z^{2}}{2} + \\frac{z^{4}}{24} + O\\left(z^{6}\\right)$\nC) $f(z) = \\sin(z)$ para $a = 0$ Calculando as derivadas:\n$f^0(z)=\\sin(z) \\Rightarrow f^0(0) = 0$\n$f^1(z)=\\cos(z) \\Rightarrow f^1(0) = 1$\n$f^2(z)=-\\sin(z) \\Rightarrow f^2(0) = 0$\n$f^3(z)=-\\cos(z) \\Rightarrow f^3(0) = -1$\n$f^4(z)=\\sin(z) \\Rightarrow f^4(0) = 0$\n$f^5(z)=\\cos(z) \\Rightarrow f^5(0) = 1$\nPara k = 0\n$(z-0)^0 \\frac{f^0(0)}{0!} = 0$\nPara k = 1\n$(z-0)^1 \\frac{f^1(0)}{1!} = z$\nPara k = 2\n$(z-0)^2 \\frac{f^2(0)}{2!} = 0$\nPara k = 3\n$(z-0)^3 \\frac{f^3(0)}{3!} = -\\frac{z^3}{3!}$\nPara k = 4\n$(z-0)^4 \\frac{f^4(0)}{4!} = 0$\nPara k = 5\n$(z-0)^5 \\frac{f^5(0)}{5!} = \\frac{z^5}{5!}$\nEntão:\n\\box{$f(z) = z - \\frac{z^3}{3!} + \\frac{z^5}{5!} … $\n#Computacionalmente: series(sin(z),z) $\\displaystyle z - \\frac{z^{3}}{6} + \\frac{z^{5}}{120} + O\\left(z^{6}\\right)$\nD) $f(z) = \\frac{1}{z}$ para $a = 1$ Calculando as derivadas:\n$f^0(z)=\\frac{1}{z} \\Rightarrow f^0(1) = 1$\n$f^1(z)=-\\frac{1}{z^2} \\Rightarrow f^1(1) = -1$\n$f^2(z)=\\frac{2}{z^3} \\Rightarrow f^2(1) = 2!$\n$f^3(z)=-\\frac{3!}{z^4} \\Rightarrow f^3(1) = -3!$\n$f^4(z)=\\frac{4!}{z^5} \\Rightarrow f^4(1) = 4!$\nPara k = 0\n$(z-1)^0 \\frac{1}{0!} = 1$\nPara k = 1\n$(z-1)^1 \\frac{-1}{1!} = -(z-1)$\nPara k = 2\n$(z-1)^2 \\frac{2!}{2!} = (z-1)^2$\nPara k = 3\n$(z-1)^3 \\frac{3!}{3!} = -(z-1)^3$\nPara k = 4\n$(z-1)^4 \\frac{4!}{4!} = (z-1)^4$\nEntão:\n$f(z) = 1 -(z-1) + (z-1)^2 - (z-1)^3 + (z-1)^4 … $\n#Computacionalmente: series(1/z, z, 1) $\\displaystyle 2 + \\left(z - 1\\right)^{2} - \\left(z - 1\\right)^{3} + \\left(z - 1\\right)^{4} - \\left(z - 1\\right)^{5} - z + O\\left(\\left(z - 1\\right)^{6}; z\\rightarrow 1\\right)$\nE) $f(z) = \\ln(z)$ para $a = 1$ Calculando as derivadas:\n$f^0(z)= \\ln(z) \\Rightarrow f^0(1) = 0 $\n$f^1(z)=\\frac{1}{z} \\Rightarrow f^1(1) = 1$\n$f^2(z)=-\\frac{1}{z^2} \\Rightarrow f^2(1) = -1$\n$f^3(z)=\\frac{2}{z^3} \\Rightarrow f^3(1) = 2!$\n$f^4(z)=-\\frac{3!}{z^4} \\Rightarrow f^4(1) = -3!$\nPara k = 0\n$(z-1)^0 \\frac{0}{0!} = 0$\nPara k = 1\n$(z-1)^1 \\frac{1}{1!} = (z-1)$\nPara k = 2\n$(z-1)^2 \\frac{-1}{2!} = -\\frac{(z-1)^2}{2}$\nPara k = 3\n$(z-1)^3 \\frac{2!}{3!} = \\frac{(z-1)^3}{3}$\nPara k = 4\n$(z-1)^4 \\frac{3!}{4!} = -\\frac{(z-1)^4}{4}$\nEntão:\n$f(z) = (z-1) -\\frac{(z-1)^2}{2} + \\frac{(z-1)^3}{3} -\\frac{(z-1)^4}{4} … $\n#Computacionalmente: series(ln(z),z, 1) $\\displaystyle -1 - \\frac{\\left(z - 1\\right)^{2}}{2} + \\frac{\\left(z - 1\\right)^{3}}{3} - \\frac{\\left(z - 1\\right)^{4}}{4} + \\frac{\\left(z - 1\\right)^{5}}{5} + z + O\\left(\\left(z - 1\\right)^{6}; z\\rightarrow 1\\right)$\nF) $f(z) = \\cosh(z)$ para $a = 0$ Calculando as derivadas:\n$f^0(z)= \\cosh(z) \\Rightarrow f^0(0) = 1 $\n$f^1(z)= \\sinh(z) \\Rightarrow f^1(0) = 0$\n$f^2(z)= \\cosh(z) \\Rightarrow f^0(0) = 1 $\n$f^3(z)= \\sinh(z) \\Rightarrow f^1(0) = 0$\n$f^4(z)= \\cosh(z) \\Rightarrow f^0(0) = 1 $\nPara k = 0\n$(z-0)^0 \\frac{1}{0!} = 1$\nPara k = 1\n$(z-0)^1 \\frac{0}{1!} = 0$\nPara k = 2\n$(z-0)^2 \\frac{1}{2!} = \\frac{z^2}{2}$\nPara k = 3\n$(z-0)^3 \\frac{0}{3!} = 0$\nPara k = 4\n$(z-0)^4 \\frac{1}{4!} = \\frac{z^2}{4!}$\nEntão:\n$f(z) = 1 + \\frac{z^2}{2} + \\frac{z^4}{4!} … …","date":1700352000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1700420400,"objectID":"d15fba87ee6a9c78cfe2f856904ce216","permalink":"https://lgrando1.github.io/post/complex4/","publishdate":"2023-11-19T00:00:00Z","relpermalink":"/post/complex4/","section":"post","summary":"Expansão tanto algebricamente, quanto utilizando biblioteca Sympy no Python","tags":["Matemática","números","complexos","aprendizagem","Taylor"],"title":"Números Complexos - Pt. 4","type":"post"},{"authors":[],"categories":[],"content":"#importar as bibliotecas import matplotlib.pyplot as plt import numpy as np import cmath plt.rcParams.update({ \u0026#34;text.usetex\u0026#34;: True, \u0026#34;font.family\u0026#34;: \u0026#34;sans-serif\u0026#34;, \u0026#34;font.sans-serif\u0026#34;: \u0026#34;Helvetica\u0026#34;, }) #import sympy from sympy import I, re, im, Abs, arg, conjugate, solve, Symbol, deg, sqrt from sympy import exp, sin, cos, symbols from sympy import exp_polar, pi, I, sqrt # função para plotar o número - Modificado para o Sympy def plotapolar(z): fig, ax = plt.subplots(subplot_kw={\u0026#39;projection\u0026#39;: \u0026#39;polar\u0026#39;}, figsize=(4, 4)) ax.plot(arg(z), abs(z), marker=\u0026#39;o\u0026#39;, markersize=15, color=\u0026#39;red\u0026#39;) ax.quiver(0, 0, float(re(z)), float(im(z)), scale=0.1) plt.show() Lista com exercícios envolvendo números complexos Códigos disponíveis aqui\n1. Expresse $1-\\sqrt{3}i$ na forma polar (faça o gráfico) z = 1-sqrt(3)*I z $\\displaystyle 1 - \\sqrt{3} i$\nabs(z) $\\displaystyle 2$\narg(z) $\\displaystyle - \\frac{\\pi}{3}$\nplotapolar(z) 2. Faça o gráfico de $|z-(1.1+2i)|\u0026lt;0.05$ Expandindo resulta em uma equação da reta,\n$\\sqrt{(x-1.1)^2+(y-2)^2} \u0026lt; 0.05$\nO gráfico abaixo mostra os pontos (pintados) para os pontos solicitados.\n# ponto central do circulo z = 1.1 + 2 theta = np.linspace( 0 , 2 * np.pi , 150 ) #raio do circulo maior, apenas para referencia radius = 0.5 #raio do circulo menor radius1 = 0.05 # Desenhando o circulo maior a = float(re(z)) - radius * np.cos( theta ) b = float(im(z)) - radius * np.sin( theta ) # Desenhando o circulo menor, aberto a1 = float(re(z)) - radius1 * np.cos( theta ) b1 = float(im(z)) - radius1 * np.sin( theta ) # Pintando a area desejada Drawing_colored_circle = plt.Circle(( float(re(z)) , float(im(z)) ), radius1 ) # Plotando a figura: figure, axes = plt.subplots( 1 ) axes.plot( a, b ) axes.plot( a1, b1 , linestyle = \u0026#39;dotted\u0026#39;) axes.add_artist( Drawing_colored_circle ) axes.set_aspect( 1 ) axes.set_xlabel(\u0026#34;Real (z)\u0026#34;) axes.set_ylabel(\u0026#34;Imag (z)\u0026#34;) #para criar a anotação e a seta indicativa axes.annotate(r\u0026#39;$\\varepsilon \u0026lt; 0.05$\u0026#39;, (float(re(z))+0.01, float(im(z))+0.01), xytext=(0.75, 0.6), textcoords=\u0026#39;axes fraction\u0026#39;, arrowprops=dict(facecolor=\u0026#39;black\u0026#39;, shrink=0.05), fontsize=12, horizontalalignment=\u0026#39;right\u0026#39;, verticalalignment=\u0026#39;top\u0026#39;) #plt.title( \u0026#39;Parametric Equation Circle\u0026#39; ) plt.show() 3 - Faça o gráfico de $\\Re(z) \\geq 1$ se $z = x + yi$\nEntão $\\Re(z) = x$ e desta forma seria a área maior e igual a 1.\nSão os pontos ilustrados abaixo:\n# Código apenas para representação: fig, ax = plt.subplots() plt.vlines(x=1, ymin = 0, ymax = 2, color=\u0026#39;r\u0026#39;, linestyle=\u0026#39;solid\u0026#39;) ax.set(xlim=(0, 2), xticks=np.arange(0, 2), ylim=(0, 2), yticks=np.arange(0, 2) ) y = np.array([0, 2]) x1 = np.array([2,2]) x2 = np.array([1,1]) ax.set_xlabel(\u0026#34;Real (z)\u0026#34;) ax.set_ylabel(\u0026#34;Imag (z)\u0026#34;) ax.fill_betweenx(y, x1, x2, where=(x1 \u0026gt; x2), color=\u0026#39;C0\u0026#39;, alpha=0.3) plt.show() 4 - Ache a imagem da linha $Re(z) = 1$ sob o plano $f(z) = z^2$. Onde $f(z)$ dá origem à imagem em $f(w)$. Faça o gráfico $w = f(z) = z^2 = (x+yi)^2 = x^2-y^2+2xyi$\n$u = x^2-y^2$ $v = 2xy$\nComo $\\Re(z) = x$ então neste caso para $x = 1$\nResultando em:\n$v = 2y \\rightarrow \\frac{v}{2}$\n$u = 1-y^2 \\rightarrow 1- \\frac{v^2}{4}$\nplt.figure(figsize = ((12,5))) ax1 = plt.subplot(1,2,1) ax2 = plt.subplot(1,2,2) ax1.vlines(x=1, ymin = -2, ymax = 2, color=\u0026#39;r\u0026#39;, linestyle=\u0026#39;solid\u0026#39;) ax1.set_title(\u0026#34;Plano z\u0026#34;) ax1.set_xlabel(\u0026#34;Real (z)\u0026#34;) ax1.set_ylabel(\u0026#34;Imag (z)\u0026#34;) v = np.arange(-2, 2, 0.01) u = 1 - (v**2)/4 ax2.plot(u,v) ax2.set_title(\u0026#34;Plano w\u0026#34;) ax2.set_xlabel(\u0026#34;Real(w) = u(x,y)\u0026#34;) ax2.set_ylabel(\u0026#34;Imag(w) = v(x,y)\u0026#34;) Text(0, 0.5, \u0026#39;Imag(w) = v(x,y)\u0026#39;) 5. Diferencie: Lembrando:\nSuponha que $f$ e $g$ são diferenciaveis em $z$, e $h$ é diferenciavel em $f(z)$. Sendo $c \\in \\mathbb{C}$\n1 - $(cf)’(z) = cf’(z)$;\n2 - $(f+g)’(z) = f’(z)+g’(z)$;\n3 - Regra do Produto:\n$(f \\cdot g)’(z) = f’(z)g(z)+f(z)g’(z)$;\n4 - Regra do quociente:\n$(\\frac{f}{g})’(z) = \\frac{g(z)f’(z)-f(z)g’(z)}{g(z)^2}$, para $g(z) \\neq 0$;\n5 - Regra da cadeia:\n5 - $(h \\circ f)’(z) = h’(f(z))f’(z)$.\na) $f(z) = 3z^4-5z^3+2z$\nimport sympy x, y, a, b, c, z = sympy.symbols(\u0026#39;x y a b c z\u0026#39;) expr = 3*z**4-5*z**3+2*z expr $\\displaystyle 3 z^{4} - 5 z^{3} + 2 z$\n# Importar o módulo de derivadas from sympy import diff diff(expr,z) $\\displaystyle 12 z^{3} - 15 z^{2} + 2$\nb) $f(z) = \\frac{z^2}{4z+1}$\nPara resolver, não esquecer:\nUtilizar a regra do quociente lembrar que $g(z) \\neq 0$ exp1 = z**2 / (4*z+1) exp1 $\\displaystyle \\frac{z^{2}}{4 z + 1}$\ndiff(exp1,z) $\\displaystyle - \\frac{4 z^{2}}{\\left(4 z + 1\\right)^{2}} + \\frac{2 z}{4 z + 1}$\nPara $z \\neq -\\frac{1}{4}$\n6. Mostre que $f(z) = x + 4iy$ não é diferenciável em nenhum ponto; Forma 1 - Teorema de Cauchy-Reimann\nu = x\ny = 4i\nu = x v = 4*y diff(u,x) == diff(v,y) False diff(u,y) == -diff(v,x) True Forma 2 - Fazendo $\\Delta z = \\Delta x + i \\Delta y$\nPortanto:\n$\\lim_{\\Delta z \\to 0} \\frac{ f(z+\\Delta z)-f(z)}{\\Delta z}$\nResultando em:\n$f(z + \\Delta z) - f(z) = x + \\Delta x + 4i(y+ \\Delta y) - x - 4iy = \\Delta x + 4i \\Delta y$\ne\n$\\lim_{\\Delta z \\to 0}\\frac{\\Delta x + 4i\\Delta y}{\\Delta x + i\\Delta y}$\nQuando $\\Delta z \\to 0$ ao …","date":1699142400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1699210800,"objectID":"04e7252706ebbfb129825c6a8e2a4a5c","permalink":"https://lgrando1.github.io/post/complex3/","publishdate":"2023-11-05T00:00:00Z","relpermalink":"/post/complex3/","section":"post","summary":"Tópico: Operações básicas e derivadas","tags":["Matemática","números","complexos","aprendizagem","exercícios"],"title":"Números Complexos - Pt. 3","type":"post"},{"authors":[],"categories":[],"content":"Pt 2 - Forma Polar/Exponencial/Funções/Cauchy-Riemann A Parte 1 deste série considera as operações com as coordenadas cartesianas;\nOperações Básicas com Números Complexos 1.1 - Utilizando o Python para efetuar os cálculos Representação Polar/Exponencial 2.1 Multiplicação e divisão de números polares 2.2 - Utilizando o Sympy Raízes de z Função complexa Equações de Cauchy-Riemann Código disponível aqui: https://github.com/lgrando1/Notas_Numeros_Complexos/\n1. Operações Básicas com Números Complexos Considere os números complexos abaixo:\na = 2 + 3j\nb = 1j\nc = 4 + 1j\nd = 5 - 2j\nCalcule:\n1a) a+b =\n1b) a+c =\n1c) d-a =\n1d) b-d =\n1e) a * b =\n1f) b * c =\n1g) a / c =\n1h) d / c =\nCalcule do valor absoluto (módulo) dos números complexos:\n1i) |a| =\n1j) |b - d| =\nCalcule o conjugado dos números complexos:\n1l) $\\bar{c}$\n1m) $\\overline{c+b}$\n1.1 - Utilizando o Python para efetuar os cálculos: # Definindo os números a = 2 + 3j b = 1j c = 4 + 1j d = 5 - 2j print(\u0026#34;1a:\u0026#34;, a+b) 1a: (2+4j) print(\u0026#34;1b:\u0026#34;,a+c) 1b: (6+4j) print(\u0026#34;1c:\u0026#34;,d-a) 1c: (3-5j) print(\u0026#34;1d:\u0026#34;,b-d) 1d: (-5+3j) print(\u0026#34;1e:\u0026#34;,a * b) 1e: (-3+2j) print(\u0026#34;1f:\u0026#34;,b * c) 1f: (-1+4j) print(\u0026#34;1g:\u0026#34;,a / c) 1g: (0.6470588235294118+0.5882352941176471j) print(\u0026#34;1h:\u0026#34;,d / c) 1h: (1.0588235294117647-0.7647058823529411j) print(\u0026#34;1i:\u0026#34;,abs(a)) 1i: 3.605551275463989 print(\u0026#34;1j:\u0026#34;,abs(b - d)) 1j: 5.830951894845301 print(\u0026#34;1l:\u0026#34;,c.conjugate()) 1l: (4-1j) print(\u0026#34;1m:\u0026#34;,c.conjugate()+b.conjugate()) 1m: (4-2j) OBS: Sugestões para gráficos em Python: https://python-graph-gallery.com/\nFunção no Python para plotar um número utilizando a biblioteca Matplotlib\n#importar as bibliotecas import matplotlib.pyplot as plt import numpy as np #criando uma função para plotar def plotargant(x): ponto = np.array(x) x = ponto.real y = ponto.imag fig, ax = plt.subplots(1, figsize=(6, 4)) ax.scatter(x, y, s = 100, color = \u0026#39;red\u0026#39;) ax.quiver(0, 0, x,y, units=\u0026#39;xy\u0026#39;, angles=\u0026#39;xy\u0026#39;, scale=1) ax.spines[\u0026#39;left\u0026#39;].set_position(\u0026#39;zero\u0026#39;) ax.spines[\u0026#39;right\u0026#39;].set_color(\u0026#39;none\u0026#39;) ax.spines[\u0026#39;bottom\u0026#39;].set_position(\u0026#39;zero\u0026#39;) ax.spines[\u0026#39;top\u0026#39;].set_color(\u0026#39;none\u0026#39;) ax.set_ylabel(\u0026#39;Im\u0026#39;) ax.set_xlabel(\u0026#39;Re\u0026#39;) #ax.show() print(\u0026#34;Gráfico ponto a\u0026#34;) plotargant(a) Gráfico ponto a print(\u0026#34;Gráfico 1l\u0026#34;) plotargant(c.conjugate()) Gráfico 1l 2. Representação Polar/Exponencial Converta os números a seguir em polar: 2a) a = 2 + 3j\n2b) b = 1j\n2c) c = 4 + 1j\n2d) d = 5 - 2j\nA fórmula de Euler:\n$e^{j\\theta} = \\cos\\theta + j\\sin\\theta$\nPode ser utilizada para representar um número complexo na fórmula polar:\n$z = re^{j\\theta} = r\\cos\\theta+jr\\sin\\theta = r(\\cos\\theta+j\\sin\\theta)$\nLembrando: $|z| = r = \\sqrt{x^2 + y^2} = \\sqrt{z\\bar{z}}$\nO principal argumento do ângulo: $-\\pi \u0026lt; \\theta \u0026lt; \\pi$.\nOutros valores possíveis para $\\theta = \\theta + 2n\\pi$, onde $n = \\pm 1, \\pm 2, …$\nO número complexo $z = 1+1i$ pode ser representado das seguintes formas:\nForma cartesiana: $z = 1+1i$ Forma polar: $\\sqrt{2}(\\cos(\\frac{\\pi}{4}) + i \\sin(\\frac{\\pi}{4}))$ Forma exponencial: $\\sqrt{2}e^{i\\pi/4}$ #definindo os números nos Python: a = 2 + 3j b = 1j c = 4 + 1j d = 5 - 2j #importando a biblioteca cmath (para cálculos dos complexos) import cmath cmath.polar(a) (3.605551275463989, 0.982793723247329) cmath.polar(b) (1.0, 1.5707963267948966) Neste caso (2a) o número 2 + 3j, pode ser representado como o valor\naproximado de r = 3,60 e o argumento de 0,98 radianos ou melhor (56,3 graus).\nUtilizando a notação de Euler:\n$a = 2+3j = 3.6e^{j0.98}=3.6(\\cos{0.98}+j\\sin{0.98})$\nComandos interessantes para o cmath:\n#Para calcular o modulo de a: abs(a) 3.605551275463989 #para obter o valor do angulo Theta: cmath.phase(a) 0.982793723247329 # Importar a biblioteca math (para calcular o arco tangente) import math #que é igual a: math.atan(a.imag/a.real) 0.982793723247329 #convertendo para graus round(math.degrees(cmath.phase(a)), 1) 56.3 # Realizando o caminho inverso # a forma polar para a forma algébrica # r*(cos(theta) + i sen(theta) para # (x+yj) abs(a) * (math.cos(cmath.phase(a)) + math.sin(cmath.phase(a))*1j) (2+3j) # função para plotar o número def plotapolar(z): fig, ax = plt.subplots(subplot_kw={\u0026#39;projection\u0026#39;: \u0026#39;polar\u0026#39;}, figsize=(4, 4)) ax.plot(cmath.phase(z), abs(z), marker=\u0026#39;o\u0026#39;, markersize=15, color=\u0026#39;red\u0026#39;) ax.quiver(0, 0, z.real, z.imag, scale=0.1) plt.show() plotapolar(a) # 2b) b = 1j print(cmath.polar(b)) plotapolar(b) (1.0, 1.5707963267948966) # 2c) c = 4 + 1j print(cmath.polar(c)) plotapolar(c) (4.123105625617661, 0.24497866312686414) #2d) d = 5 - 2j print(cmath.polar(d)) plotapolar(d) (5.385164807134504, -0.3805063771123649) 2.1 Multiplicação e divisão de números polares Sendo:\n$z_1 = r_1(\\cos\\theta_1 + i\\sin \\theta_1)$\n$z_2 = r_2(\\cos\\theta_2 + i\\sin \\theta_2)$\nMultiplicação para a forma polar:\n$z_1z_2= r_1r_2[\\cos(\\theta_1+\\theta_2) + i \\sin((\\theta_1+\\theta_2)]$\nDivisão para a forma polar\n$\\frac{z_1}{z_2}= \\frac{r_1}{r_2}[\\cos(\\theta_1-\\theta_2) + i \\sin((\\theta_1-\\theta_2)]$\nLembrando que:\n$arg(z_1z_2) = arg z_1 + arg z_2$ e\n$arg(\\frac{z_1}{z_2}) = arg z_1 -arg z_2$\nCalcule a multiplicação e divisão …","date":1691712000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1694286000,"objectID":"5c1f24ef5834469f40dcd1da90f6cad9","permalink":"https://lgrando1.github.io/post/complexex1/","publishdate":"2023-08-11T00:00:00Z","relpermalink":"/post/complexex1/","section":"post","summary":"Exercícios operações básicas números complexos","tags":["Matemática","números","complexos","aprendizagem"],"title":"Números Complexos - Pt.2","type":"post"},{"authors":[],"categories":[],"content":"Pt 1 - Introdução Nesta série de postagens, trataremos dos números complexos.\nUtilizaremos o Python como linguagem de programação.\nA Parte 1 deste série considera as operações com as coordenadas cartesianas;\nNúmeros complexos\n1.1 - O módulo de um número complexo\n1.2 - O Conjugado de um Número Complexo\nOperações Básicas\n2.1 - Adição\n2.2 - Subtração\n2.3 - Multiplicação de números complexos\n2.4 - Divisão de números Complexos\nCódigo disponível aqui: https://github.com/lgrando1/Notas_Numeros_Complexos/\n1. Números complexos Elemento de um sistema numérico que contém os números reais e um elemento especifico denominado $i$, chamado de unidade imaginária, e satisfaz a equação $i^2 = -1$.\nPlano Complexo Números complexos são expressões da forma $z = x + iy$ ou $z = x + jy$, onde:\n$x$ é a parte real de $z$ ou $x = Re$ z; $y$ é a parte imaginária de $z$ ou $y = Im$ z. A representação cartesiana de um número complexo $z = 2 + j1$:\nO conjunto de números complexos é chamado de plano complexo cujo simbolo é $\\mathbb{C}$ e pode ser identificada como $\\mathbb{R}^2$.\nOs números reais são um conjunto do plano complexo onde a parte imaginaria é zero.\nConforme a biblioteca utilizada no Python, pode-se representar o elemento $i$ como a letra $j$, no caso da biblioteca cmath para representar a parte imaginaria de um número complexo Já a biblioteca Sympy utilizasse a Letra $I$.\nEntão a o numero $z = 2+3i$ pode ser descrito no Python como:\n#Definindo o número: z = 2 + 3j print(\u0026#34;Representação do número\u0026#34;) print(z) Representação do número (2+3j) print(\u0026#34;Classe de z\u0026#34;) print(type(z)) Classe de z \u0026lt;class \u0026#39;complex\u0026#39;\u0026gt; Um numero complexo pode ser representado por um ponto no plano complexo $\\mathbb{C}$ e o numero $z = 2+3j$ pode ser representado no Python:\nprint(complex(2,3)) (2+3j) print(\u0026#34;Parte real de z\u0026#34;) print(z.real) Parte real de z 2.0 print(\u0026#34;Parte complexa de z\u0026#34;) print(z.imag) Parte complexa de z 3.0 1.1 - O módulo de um número complexo O módulo de um número complexo $z = x + iy$ é a distância entre o ponto $z$ e a origem, utilizando o Teorema de Pitágoras:\n$|z| = \\sqrt{x^2 + y^2}$\nEm Python, pode obter este valor pela função abs(z):\nz = 1+4i\nw = 4+2i\nz = 1+4j w = 4+2j print(f\u0026#34;O módulo de z é: {abs(z)}\u0026#34;) O módulo de z é: 4.123105625617661 print(f\u0026#34;O módulo de w é: {abs(w)}\u0026#34;) O módulo de w é: 4.47213595499958 1.2 - O Conjugado de um Número Complexo O conjugado do número complexo $z = x + iy$ é $\\overline{z} = x - iy$\nPropriedades do conjugado:\n$\\overline{\\overline{z}} = z$\n$\\overline{z+w} = \\bar{z}+\\bar{w}$\n$\\overline{z} = |\\overline{z}|$\n$z\\overline{z} = (x+iy)(x-iy) = x^2+y^2 = |z|²$\n$\\frac{1}{z} = \\frac{\\overline{z}}{z\\overline{z}}= \\frac{\\bar{z}}{|z|²}$\n$|z \\cdot w| = |z|\\cdot|w|$\n$\\overline{(\\frac{z}{w})} = \\frac{\\overline{z}}{\\overline{w}}$, quando $w \\neq 0$\n$|z| = 0$ se e somente se $z = 0$\nPara encontrar os valores Reais e imaginários de z,\npodemos fazer $z = \\overline{z}$ ou $z = -\\overline{z}$, resultando em:\n$Re$ z $= \\frac{z + \\overline{z}}{2}$\n$Im$ z $= \\frac{z - \\overline{z}}{2i}$\nPara obter o conjugado de um número complexo $z$ em Python:\nz = 3+2j print(z.conjugate()) (3-2j) Algumas desigualdades:\n$-|z|\\leq Re$ z $ \\leq |z|$\n$-|z|\\leq Im$ z $ \\leq |z|$\nDesigualdade triangular $|z+w| \\leq |z| + |w|$\nGeneralizando:\n$|z_1+z_2 + … z_n| \\leq |z_1| + |z_2|+ … + |z_n|$\nDesigualdade triangular inversa $|z-w| \\geq |z| - |w|$\n2. Operações Básicas 2.1 - Adição Se $z = x + iy$ e $w = u + iv$, podemos representar z + w como:\n$(x + iy) + (u + iv) = (x+u) + i(y+v)$, onde:\nRe$(z+w)$ = Re $z$ + Re $w$ Im$(z+w)$ = Im $z$ + Im $w$ 2.2 - Subtração Se $z = x + iy$ e $w = u + iv$, podemos representar z - w como:\n$(x + iy) - (u + iv) = (x-u) + i(y-v)$, onde:\nRe $(z-w)$ = Re $z$ - Re $w$ Im $(z-w)$ = Im $z$ - Im $w$ Em Python para z = 1+4i e w = 4+2i\nz = 1+4j w = 4+2j print(f\u0026#34;O valor de z+w é, {z+w}\u0026#34;) print(f\u0026#34;O valor de z-w é, {z-w}\u0026#34;) O valor de z+w é, (5+6j) O valor de z-w é, (-3+2j) 2.3 - Multiplicação de números complexos $(x+iy) \\cdot (u-iv) = (xu-yv)+i(xv+yu) \\in \\mathbb{C}$\nPropriedades:\nAssociativas: $(z_1z_2)z_3 = z_1(z_2z_3)$; Comutativas: $z_1z_2 = z_2z_1$; Distributivas: $z_1(z_2+z_3) = z_1z_2+ z_1z_3)$. Exemplo\na = 2+4j\nb = -7+5j\n$(2+4j) \\cdot (-7+5j) = (2 \\cdot -7 - 5 \\cdot 4) + j(2 \\cdot 5 + 4 \\cdot -7)$\n$= -34-18j$\nEfetuando a multiplicação dos números a, b e c:\na = 2+4j b = -7+5j c = 3+2j print(\u0026#34;a * b = \u0026#34;, a * b) print(\u0026#34;a * c = \u0026#34;, a * c) a * b = (-34-18j) a * c = (-2+16j) Verificando se as propriedades são verdadeiras\n#Propriedades print(\u0026#34;Associativa: (a*b)*c == a*(b*c)\u0026#34;) print((a*b)*c == a*(b*c)) Associativa: (a*b)*c == a*(b*c) True print(\u0026#34;Comutativa: a*b == b*a\u0026#34;) print(a*b == b*a) Comutativa: a*b == b*a True print(\u0026#34;Distributiva: a*(b+c) == a*b + a*c\u0026#34;) print(a*(b+c) == a*b + a*c) Distributiva: a*(b+c) == a*b + a*c True As Potências de $i$:\n$i^0 = 1$\n$i = 0 + 1i$\n$i^2 = (0 + 1i)(0 + 1i) = (0\\cdot0 - 1\\cdot1) + i(0\\cdot1+1\\cdot0) = -1$\n$i^3 = i^2 \\cdot i = -1\\cdot i = -i $\n$i^4 = i^2 \\cdot i^2 = -1\\cdot -1 = 1 $\n$i^5 = i^4 \\cdot i = …","date":1691366400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1694286000,"objectID":"718d6e0a2b0a6ba6585412b1ca109191","permalink":"https://lgrando1.github.io/post/complex1/","publishdate":"2023-08-07T00:00:00Z","relpermalink":"/post/complex1/","section":"post","summary":"O que são números e algumas operações básicas","tags":["Matemática","números","complexos","aprendizagem"],"title":"Números Complexos - Pt. 1","type":"post"},{"authors":[],"categories":[],"content":"A tecnologia e seus avanços são maravilhosos, eu mesmo sou uma pessoa enviesada nesta questão, pois amo a tecnologia, mas isto não tem valor, se não pensarmos em seus efeitos futuros1.\nMeu pedido à todos é:\nNão apenas comemorar os avanços da tecnologia, sem antes pensarmos em como mitigar seus possíveis efeitos negativos na vida das pessoas.\nAcredito que devemos ser conscientes e críticos com os avanços, com o intuito de garantir que todos tenham sua humanidade preservada. Se o efeito for positivo, vamos todos comemorar, agora se o efeito for negativo, vamos pensar melhor.\nAlguns exemplos:\nUma nova I.A possui a capacidade de elaborar relatórios ou realizar atendimentos de forma automatizada -\u0026gt; Como treinar as pessoas que efetuavam este trabalho para novas atividades. Um sistema de veículos autônomo irá substituir os motoristas -\u0026gt; Como treinar as pessoas que efetuavam este trabalho para novas atividades. Você está se aprimorando para entender esta nova tecnologia funciona/trabalha?, você esta atuando como um “motor de inovação” para sua comunidade?, você está mostrando como utilizar está nova tecnologia e suas armadilhas?. etc, etc. Temos que fazer nossa parte, para que todos sejam respeitados no futuro.\nhttps://notbyai.fyi/ Lembrando:É um trabalho em andamento, ideias são sempre bem vindas.\n1 ONLINE, É. N. “Uma nova classe de pessoas deve surgir até 2050: a dos inúteis”. Disponível em: https://epocanegocios.globo.com/Vida/noticia/2018/01/uma-nova-classe-de-pessoas-deve-surgir-ate-2050-dos-inuteis.html.\n‌\nPara comentários e sugestões, clique aqui\nControle de versão: v00 [19/03] - Versão inícial em PT-BR\nTODO: Traduzir para inglês. Pensar mais exemplos\n","date":1679184000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1679238560,"objectID":"f35ed3c73b3b8870e1fd465571ef3d42","permalink":"https://lgrando1.github.io/post/pedido/","publishdate":"2023-03-19T00:00:00Z","relpermalink":"/post/pedido/","section":"post","summary":"Como aproveitar a tecnologia de modo consciente","tags":["tecnology","future of work","AI"],"title":"Apenas um pedido","type":"post"},{"authors":[],"categories":[],"content":"Sugestões (empíricas) para usufruir o melhor da Internet.\ni. Não ofenda o próximo. -\u0026gt; Somos todos irmãos. ii. Sempre utilize sua cognição e lógica -\u0026gt; não acredite em tudo. iii. Faça back-up do que é importante -\u0026gt; Evite ser surpreendido. iv. Nunca utilize a mesma senha em dois lugares distintos -\u0026gt; Evite ser surpreendido (x2). v. Sempre utilize todos os métodos de segurança disponíveis -\u0026gt; Evite ser surpreendido (x3). vi. Gaste pouco (ou não gaste) tempo nas redes sociais -\u0026gt; Leia um livro, converse com seus amigos/família. vii. Cuide de seu dinheiro e de seus dados -\u0026gt; Os seus dados (e seu conhecimento) são seus maiores patrimônios. viii. Sempre prefira o open source -\u0026gt; Tudo que é aberto/auditável acaba sendo mais confiável. ix. Sempre leia os Termos dos serviços (TOS) -\u0026gt; Evite ser surpreendido (x4). x. Você nunca está totalmente seguro -\u0026gt; Sempre se aprimore. Os seus dados (e seu conhecimento) são seus maiores patrimônios (x2). https://notbyai.fyi/ Lembrando:É um trabalho em andamento, idéias são sempre bem vindas.\nPara sugestões\nControle de versão: v00 [18/03/23] - Versão inícial em PT-BR\nTODO: Traduzir para inglês.\n","date":1679097600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1679152160,"objectID":"afd02caf03216c6b1ead225b207b8115","permalink":"https://lgrando1.github.io/post/rules/","publishdate":"2023-03-18T00:00:00Z","relpermalink":"/post/rules/","section":"post","summary":"Algumas lições que aprendi utilizando a tecnologia","tags":["rules","security","data","WIP"],"title":"10 \"Mandamentos\" para os tempos modernos","type":"post"},{"authors":[],"categories":[],"content":"Language post available: PT-BR\nEN\nFollow below a resource list that I use to learn. This post is an organic list.\nFirst, a great thanks to all resources responsible cited in this. Any resource suggestions or corrections, let me know. I wish great learning to you. Total links: 27 1 - Get informed: Links to inform you.\nHacker News 👉 Social news website when users discuss computing and entrepreneurship. The best news is voted Slashdot 👉 News source of technology Awesome Lists 👉 Lists of awesome and interesting topics Telegram Data Science, Programação e Simulação Channel 👉 Telegram channel with Machine Learning, Artificial Intelligence and Simulation news 2 - General Programming Learning: Links about general programming.\nFreeCodeCamp 👉 Several programming courses and certifications. Youtube channel also OsProgramadores 👉 Brazilian Group for new programming learners with challenges and Telegram chat Computacional 👉 Computational Thinking Brazilian portal CT-STEM 👉 Northwestern University Computational STEM tools using Netlogo MIT Scratch 👉 Block type programming language. Great for starters. Possible to create stories, games, and animations. Several tutorials MIT App Inventor 👉 Block type programming language. Several tutorials. Create iPhone and Android apps in the browser and test them on your phone Roadmaps.sh 👉 List of guides to support developers learning Universidade-Livre/Ciencia-da-computacao/ 👉 Brazilian guide to computational science self-learning Save Money: Learn to Code From Home 👉 A blog reader suggestion with a lot of good resources to learn to code STEM Identity Resources for Women and Girls 👉 College Educated STEM resources list for Women and Girls 3 - Machine Learning / Artificial intelligence: Links about Artificial intelligence.\nMachine Learning for Everyone 👉 Great machine learning concepts summary Machine learning for humans 👉 Great machine learning concepts in plain English Kaggle 👉 Machine learning and Data Science portal. With competition, and Courses Data Hackers 👉 Brazilian data science community, with a Slack community R-Bloggers 👉 Blog that brings news and tutorials about R language Kdnuggets 👉 Data Science portal with great information quantity Data Science for Beginners 👉 Microsoft’s Data Science guide for beginners 4 - Books lists: Links about programming books list.\nBig book of R 👉 List of R language books Online Programming Books 👉 Books list several computing areas Green Tea Press 👉 Allen Downey books. Recommended 5 - Data Viz Resources: Links about Data visualization tools.\nData Viz Project 👉 List of Graphs and their characteristics R Graph Gallery 👉 List of charts implemented in R Python Graph Gallery 👉 List of charts implemented in Python https://notbyai.fyi/ ","date":1666483200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1719880748,"objectID":"973a855da5d5b1dd53ba76fa4d475a6e","permalink":"https://lgrando1.github.io/post/learning-resource-links/","publishdate":"2022-10-23T00:00:00Z","relpermalink":"/post/learning-resource-links/","section":"post","summary":"This post is curate some good resources helping new and experienced learners","tags":["Learning","AI","ML","Netlogo"],"title":"Learning Resource Links","type":"post"},{"authors":[],"categories":[],"content":"Post disponível em: PT-BR\nEN\nSegue abaixo uma lista de links que eu utilizo para aprender. Este post é uma lista orgânica\nPrimeiramente, um muito obrigado aos responsáveis pelos sites presentes nesta lista. Em caso de Sugestões de novos recursos ou correções, por favor me informe. Eu desejo grande aprendizado para você. Total de links: 27 1 - Fique informado: Links para te manter informado.\nHacker News 👉 Site em que usuários trazem notícias diversas sobre computação e empreendedorismo. As melhores notícias recebem votos. Slashdot 👉 Fonte de notícias sobre tecnologia Awesome Lists 👉 Conjunto de listas sobre tópicos interessantes Canal do Telegram Data Science, Programação e Simulação 👉 Canal do Telegram com novidades sobre Machine Learning, Inteligência Artificial e Simulação 2 - Aprendizado geral de computação e/ou programação: Links sobre aprendizado em programação em geral.\nFreeCodeCamp 👉 Vários cursos e certificação gratuitas sobre programação. Possui canal no Youtube. OsProgramadores 👉 Grupo Brasileiro voltado para novos programadores, com desafios e suporte via chat do Telegram Computacional 👉 Portal brasileiro sobre Pensamento Computacional e recursos educacionais CT-STEM 👉 Ferramentas computacionais STEM da Universidade de Northwesternutilizando Netlogo MIT Scratch 👉 Linguagem de programação em blocos. Ótima para iniciantes. Possibilidade de criar histórias, jogos e animações. Vários tutoriais. MIT App Inventor 👉 Linguagem de programação em blocos. Vários tutoriais. Crie aplicativos IPhone and Android no seu navegador e teste em seu celular Roadmaps.sh 👉 Lista de guias para suportar o aprendizado de desenvolvedores Universidade-Livre/Ciencia-da-computacao 👉 Guia brasileiro para aprendizado autodidata em ciência da computação Save Money: Learn to Code From Home 👉 Uma sugestão de uma leitora do blog com bons recursos para aprender a programar. STEM Identity Resources for Women and Girls 👉 Recursos do site College Educated para STEM voltado para mulheres. 3 - Aprendizado de máquina / Inteligência artificial: Links sobre Inteligencia Artificial.\nMachine Learning for Everyone 👉 Ótimo resumo para conceitos de aprendizado de máquina. Possui tradução para o português Machine learning for humans 👉 Ótimo resumo para conceitos de aprendizado de máquina em inglês simples Kaggle 👉 Portal com cursos e competição de aprendizado de máquina e ciência de dados Data Hackers 👉 Grupo brasileiro de ciência de dados com uma comunidade no Slack. R-Bloggers 👉 Blog que traz notícias e tutoriais sobre a linguagem R Kdnuggets 👉 Portal de ciência de dados com grande quantidade de informação Data Science for Beginners 👉 Guia da Microsoft para iniciantes em ciência de dados 4 - lista de Livros: Links sobre lista de livros sobre programação.\nBig book of R 👉 Lista com livros que envolvem a linguagem R Online Programming Books 👉 Lista de livros de variados temas da computação Green Tea Press 👉 Livros do autor Allen Downey - Muito recomendado 6 - Recursos para visualização de dados: Links sobre ferramentas para Visualização de dados.\nData Viz Project 👉 Lista de grafícos e suas caracterisiticas R Graph Gallery 👉 Lista de gráficos implementados em R Python Graph Gallery 👉 Lista de gráficos implementados em Python https://notbyai.fyi/ ","date":1666483200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1719880748,"objectID":"9026b7312eb26385a2e4a823dc2c371a","permalink":"https://lgrando1.github.io/post/links-interessantes-aprendizagem/","publishdate":"2022-10-23T00:00:00Z","relpermalink":"/post/links-interessantes-aprendizagem/","section":"post","summary":"Esta publicação contém bons recursos para ajudar aprendizes novos e experientes","tags":["AI","ML","Netlogo","aprendizagem"],"title":"Recursos para aprendizagem","type":"post"},{"authors":[],"categories":null,"content":"","date":1633691100,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633691100,"objectID":"3a1bd26709cd3c369113342d1d9ccdba","permalink":"https://lgrando1.github.io/talk/panel-discussion-uvm/","publishdate":"2023-12-12T00:00:00Z","relpermalink":"/talk/panel-discussion-uvm/","section":"event","summary":"In this panel discussion, I present the work \"Using a classical model to provide insights through Agent-Based Simulation.\" and discussed with other panelists about the current/future state of agent-based simulation.","tags":["Agent-Based","Simulation","presentation"],"title":"Panel Discussion UVM","type":"event"},{"authors":[],"categories":null,"content":"","date":1604494800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1604494800,"objectID":"cf75d18153edf6e0062f6ce000f0e0a4","permalink":"https://lgrando1.github.io/talk/ieemcon-2020/","publishdate":"2023-12-12T00:00:00Z","relpermalink":"/talk/ieemcon-2020/","section":"event","summary":"Present the proceeding work \"Drones Swarm Recharging - Modeling using Agent-Based Simulation\" during the 11th IEMCOM. Our paper recieve the Certificate of Best Paper in the Internet of Things category","tags":["Agent-Based","Simulation","presentation"],"title":"IEEMCON 2020","type":"event"},{"authors":["Leonardo Grando","Edson L. Ursini","Paulo S. Martins"],"categories":null,"content":"","date":1604448000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1604448000,"objectID":"2fe1dfe58d524a410b0f8fb6cfc5a789","permalink":"https://lgrando1.github.io/publication/grando-2020/","publishdate":"2020-11-04T00:00:00Z","relpermalink":"/publication/grando-2020/","section":"publication","summary":"This work seeks to address one of the most critical problems of Flying Ad Hoc Networks (FANET), which is the issue of recharging batteries coordination. For recharges to be carried out in the best possible way, the number of load devices (Base Stations) should not be excessively high so as not to burden the network. On the other hand, it is also necessary that when the drones want to recharge, there must always be a source of energy available. For this, we propose internal estimators that provide intelligence to the drones to try to predict the next charger attendance rate. The drones will not have communication with each other to recharge coordination but will continue to communicate concerning other routine activities (note that this communication is not considered in the scope of this model), that is, for recharging the batteries’ coordination, there will be no energy expenditure on communication. The verification of the suitability of the proposal is done through Agent-Based Simulation and the use of three different policies for decision making. This will enable an approach that aims to optimize the operation of the system through a Nash equilibrium.","tags":["Drones","Simulation","Agent-Based","Nash Equilibrium"],"title":"Drones Swarm Recharging: Modeling Using Agent-Based Simulation","type":"publication"},{"authors":["Leonardo Grando"],"categories":null,"content":"","date":1597968000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597968000,"objectID":"d21765dc3a0890666f87716d16c09db3","permalink":"https://lgrando1.github.io/publication/grando2020a/","publishdate":"2020-08-21T00:00:00Z","relpermalink":"/publication/grando2020a/","section":"publication","summary":"This work seeks to solve one of the most critical problems of the Flying AdHoc (FANET) networks, which is the issue of coordinating the recharging of drones that fly in the form of Swarms. For recharging to be done in the best possible way, it is desirable that the number of charging devices (base stations) did not be excessively high due to the high implementation cost. Conversely, it is also necessary that, when drones want to recharge, they must have a source of energy available. In other words, we search for a balance between the economically viable number of charging stations and the adequate energy supply for the drones when necessary. For this, we propose agents (drones) equipped with internal intelligence, that is, with internal predictors that provide intelligence to attempt to predict the next attendance rate in the charging device and thus be able to decide whether go or not go to the recharging. Ideally, the forecast should be as best as possible. Therefore, the drone should go when it predicts it should go and it shouldn't go when it predicts not to go. The Nash equilibrium usage for this problem is made possible by the modeling via the El Farol Bar Problem (EFBP), which allows the development of this analogy without the collusion of agents in coordinating the simulation of the recharge of this set of drones. In other words, there will be no energy expenditure on communication about the drones' battery recharging coordination, although the communication will continue in the other tasks inherent to the swarm of drones. The verification of the suitability of the proposal is done through Agent-Based Simulation and are used three different policies for the best predictor decision by each drone. This will allow us to verify the performance in the operation of the system through a Nash Equilibrium. In the current state of this analogy is considered that if the drones go to the charging station and it is full, there will be no possible charging because the system is overloaded. This study includes microscopic and macroscopic analysis. Microscopic analysis is the evaluation of the performance of the rewards of each predictor concerning a set of simulation parameters, aiming at a microscopic behavior performance improvement. A macroscopic analysis is the evaluation of the performance of the global service of the system with three types of policies. This latter analysis is used as a basis for evaluating the drone's recharge analogy. In this way, the performance of the best simulation sets for the recharge of drones is evaluated, which allows supplying below the control threshold (attendance below than the number of recharge positions), but which are relatively close to the threshold.","tags":["Drones","Simulation","Agent-Based","Nash Equilibrium"],"title":"Procedimento de recarga de baterias de drones utilizando simulação por agentes e equilíbrio de Nash","type":"publication"},{"authors":["Leonardo Grando"],"categories":null,"content":"","date":1259884800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1259884800,"objectID":"fcc49c55dbec452b09198fd2b2661ae4","permalink":"https://lgrando1.github.io/publication/grando-2009/","publishdate":"2009-12-04T00:00:00Z","relpermalink":"/publication/grando-2009/","section":"publication","summary":"The use of computational tools for the simulation of physical phenomena is increasing, saving time and money in new processes and materials development. This study aims to use the Java tool for developing a program to compute the kinetics of sintering of vitreous material for ceramics manufacturing. Through this process, special glasses are grinded, compacted and sintered, with simultaneous or subsequent particles crystallization. A recent solution for the sintering process of glass by viscous flow, called Cluster Model, considers the effect of surface crystallization of the particles, which limits the densification (pore elimination) of the material, and allows to deal with mixtures of particles of different sizes. We developed a program in JAVA based on the Clusters Model, for calculations of the sintering kinetics of compact particles of glass powder with different particle sizes and concurrent crystallization. Published data for glasses in the systems Al2O3-B2O3-SiO2 and CaO-MgO-SiO2 were used to check the results of the program, expressed as graphs, which repeated with great precision the literature values.","tags":["Glass","Simulation","JAVA","Crystallization"],"title":"Desenvolvimento de um Programa em Java para Cálculo da Cinética de Sinterização de Vidros.","type":"publication"}]